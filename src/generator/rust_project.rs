use std::path::{Path, PathBuf};
use std::collections::HashMap;
use anyhow::{Result, Context};

#[derive(Debug, Clone)]
pub struct RustProject {
    pub name: String,
    pub version: String,
    pub author: String,
    pub description: String,
    pub files: HashMap<PathBuf, String>,
    pub embedded_files: HashMap<String, Vec<u8>>,
    pub dependencies: Vec<CrateDependency>,
    pub build_targets: Vec<BuildTarget>,
    pub update_config: UpdateConfig,
}

#[derive(Debug, Clone)]
pub struct CrateDependency {
    pub name: String,
    pub version: String,
    pub features: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct BuildTarget {
    pub name: String,
    pub os: String,
    pub arch: String,
}

#[derive(Debug, Clone)]
pub struct UpdateConfig {
    pub repo: Option<String>,
    pub api_path: Option<String>,
    pub enabled: bool,
}

impl RustProject {
    pub fn new(script_name: &str) -> Self {
        let name = sanitize_crate_name(script_name);
        
        Self {
            name: name.clone(),
            version: "0.1.0".to_string(),
            author: "Generated by cassh2rs".to_string(),
            description: format!("Rust port of {} shell script", script_name),
            files: HashMap::new(),
            embedded_files: HashMap::new(),
            dependencies: vec![
                CrateDependency {
                    name: "anyhow".to_string(),
                    version: "1.0".to_string(),
                    features: vec![],
                },
                CrateDependency {
                    name: "clap".to_string(),
                    version: "4.5".to_string(),
                    features: vec!["derive".to_string()],
                },
                CrateDependency {
                    name: "serde".to_string(),
                    version: "1.0".to_string(),
                    features: vec!["derive".to_string()],
                },
                CrateDependency {
                    name: "toml".to_string(),
                    version: "0.8".to_string(),
                    features: vec![],
                },
                CrateDependency {
                    name: "dirs".to_string(),
                    version: "5.0".to_string(),
                    features: vec![],
                },
            ],
            build_targets: default_build_targets(),
            update_config: UpdateConfig {
                repo: None,
                api_path: None,
                enabled: false,
            },
        }
    }
    
    pub fn add_file(&mut self, path: PathBuf, content: String) {
        self.files.insert(path, content);
    }
    
    pub fn add_embedded_file(&mut self, name: String, content: Vec<u8>) {
        self.embedded_files.insert(name, content);
    }
    
    pub fn add_dependency(&mut self, dep: CrateDependency) {
        // Check if dependency already exists
        if !self.dependencies.iter().any(|d| d.name == dep.name) {
            self.dependencies.push(dep);
        }
    }
    
    pub fn set_update_config(&mut self, repo: Option<String>, api_path: Option<String>) {
        self.update_config = UpdateConfig {
            repo,
            api_path,
            enabled: repo.is_some(),
        };
    }
    
    pub fn write_to_disk(&self, output_dir: &Path) -> Result<()> {
        // Create project directory structure
        std::fs::create_dir_all(output_dir)?;
        std::fs::create_dir_all(output_dir.join("src"))?;
        std::fs::create_dir_all(output_dir.join("src/commands"))?;
        std::fs::create_dir_all(output_dir.join("src/ui"))?;
        std::fs::create_dir_all(output_dir.join("src/platform"))?;
        
        // Write Cargo.toml
        self.write_cargo_toml(output_dir)?;
        
        // Write settings.toml
        self.write_settings_toml(output_dir)?;
        
        // Write all source files
        for (path, content) in &self.files {
            let full_path = output_dir.join(path);
            if let Some(parent) = full_path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(&full_path, content)
                .with_context(|| format!("Failed to write {}", full_path.display()))?;
        }
        
        // Write embedded files as a build.rs script
        if !self.embedded_files.is_empty() {
            self.write_build_script(output_dir)?;
        }
        
        // Write .gitignore
        self.write_gitignore(output_dir)?;
        
        // Copy or generate README
        self.write_readme(output_dir)?;
        
        Ok(())
    }
    
    fn write_cargo_toml(&self, output_dir: &Path) -> Result<()> {
        let mut cargo_toml = format!(
            r#"[package]
name = "{}"
version = "{}"
edition = "2021"
authors = ["{}"]
description = "{}"

[dependencies]
"#,
            self.name, self.version, self.author, self.description
        );
        
        // Add dependencies
        for dep in &self.dependencies {
            if dep.features.is_empty() {
                cargo_toml.push_str(&format!("{} = \"{}\"\n", dep.name, dep.version));
            } else {
                cargo_toml.push_str(&format!(
                    "{} = {{ version = \"{}\", features = {:?} }}\n",
                    dep.name, dep.version, dep.features
                ));
            }
        }
        
        // Add build configuration
        cargo_toml.push_str(r#"
[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
strip = true
panic = "abort"

[[bin]]
name = "{}"
path = "src/main.rs"
"#);
        
        std::fs::write(output_dir.join("Cargo.toml"), cargo_toml)?;
        Ok(())
    }
    
    fn write_settings_toml(&self, output_dir: &Path) -> Result<()> {
        let settings = r#"[ui]
theme = "dracula"  # light|dark|dracula

[build]
targets = ["linux_amd64", "darwin_arm64", "windows_amd64"]
optimize = "size"
strip = true
compress = true

[notifications]
enabled = true
desktop = true

[smtp]
enabled = false
server = "$HOSTNAME"
port = 465
from_email = "no-reply@$HOSTNAME"
from_name = "$USER"
to = ["root@$HOSTNAME"]
subject_prefix = "[{app_name}]"

[webhooks]
slack = ""
discord = ""
teams = ""

[paths]
rust_src_dir = "rustsrc/"
build_dir = "target/"
output_dir = "dist/"

[security]
sandbox = false
validate_paths = true
confirm_deletions = true

[updates]
enabled = false
check_on_start = false
auto_download = false
channel = "stable"
"#;
        
        std::fs::write(output_dir.join("settings.toml"), settings)?;
        Ok(())
    }
    
    fn write_build_script(&self, output_dir: &Path) -> Result<()> {
        let mut build_script = String::from(
            r#"use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_files.rs");
    
    let mut content = String::from("// Auto-generated embedded files\n\n");
    
"#
        );
        
        // Generate code for each embedded file
        for (name, _) in &self.embedded_files {
            build_script.push_str(&format!(
                r#"    content.push_str("pub const {}: &[u8] = include_bytes!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/embedded/{}\"));\n");
"#,
                name.to_uppercase().replace('.', "_").replace('-', "_"),
                name
            ));
        }
        
        build_script.push_str(r#"
    fs::write(&dest_path, content).unwrap();
    
    // Set update repository if provided
    if let Ok(repo) = env::var("SCRIPT_REPO") {
        println!("cargo:rustc-env=SCRIPT_REPO={}", repo);
    }
    if let Ok(api) = env::var("RELEASE_API") {
        println!("cargo:rustc-env=RELEASE_API={}", api);
    }
}
"#);
        
        std::fs::write(output_dir.join("build.rs"), build_script)?;
        
        // Create embedded directory and write files
        let embedded_dir = output_dir.join("embedded");
        std::fs::create_dir_all(&embedded_dir)?;
        
        for (name, content) in &self.embedded_files {
            std::fs::write(embedded_dir.join(name), content)?;
        }
        
        Ok(())
    }
    
    fn write_gitignore(&self, output_dir: &Path) -> Result<()> {
        let gitignore = r#"/target
/dist
Cargo.lock
*.log
.DS_Store
"#;
        std::fs::write(output_dir.join(".gitignore"), gitignore)?;
        Ok(())
    }
    
    fn write_readme(&self, output_dir: &Path) -> Result<()> {
        let readme = format!(
            r#"# {}

{}

Generated from shell script using [cassh2rs](https://github.com/casapps/cassh2rs).

## Building

```bash
cargo build --release
```

## Cross-compilation

```bash
# Linux
cargo build --release --target x86_64-unknown-linux-gnu
cargo build --release --target aarch64-unknown-linux-gnu

# macOS
cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin

# Windows
cargo build --release --target x86_64-pc-windows-gnu
```

## Configuration

Edit `settings.toml` to customize behavior.

## Updates

Set the `SCRIPT_REPO` environment variable during build to enable self-updates:

```bash
SCRIPT_REPO=github.com/user/repo cargo build --release
```
"#,
            self.name, self.description
        );
        
        std::fs::write(output_dir.join("README.md"), readme)?;
        Ok(())
    }
}

fn sanitize_crate_name(name: &str) -> String {
    // Remove file extension
    let name = name.strip_suffix(".sh")
        .or_else(|| name.strip_suffix(".bash"))
        .or_else(|| name.strip_suffix(".zsh"))
        .or_else(|| name.strip_suffix(".fish"))
        .unwrap_or(name);
    
    // Replace invalid characters with underscores
    name.chars()
        .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
        .collect::<String>()
        .to_lowercase()
}

fn default_build_targets() -> Vec<BuildTarget> {
    vec![
        BuildTarget {
            name: "linux_amd64".to_string(),
            os: "linux".to_string(),
            arch: "x86_64".to_string(),
        },
        BuildTarget {
            name: "linux_arm64".to_string(),
            os: "linux".to_string(),
            arch: "aarch64".to_string(),
        },
        BuildTarget {
            name: "darwin_amd64".to_string(),
            os: "macos".to_string(),
            arch: "x86_64".to_string(),
        },
        BuildTarget {
            name: "darwin_arm64".to_string(),
            os: "macos".to_string(),
            arch: "aarch64".to_string(),
        },
        BuildTarget {
            name: "windows_amd64".to_string(),
            os: "windows".to_string(),
            arch: "x86_64".to_string(),
        },
    ]
}